open Core

let version = "1.0.4"
let header = sprintf "/* Generated by okTurtles/strings v%s */\n\n" version

let () = Lwt.async_exception_hook := (fun ex ->
    let open Lwt in
    let p1 = Lwt_io.write_line Lwt_io.stderr (sprintf "üíÄ PLEASE REPORT THIS BUG. UNCAUGHT EXCEPTION: %s" (Utils.Exception.human ex)) in
    let p2 = Lwt_unix.sleep 3. in
    Lwt.join [p1; p2]
    >>= (fun () -> exit 2)
    |> ignore
  )

let pool = Lwt_pool.create 6 (fun () -> Lwt.return_unit)
let (<&>) = Lwt.(<&>)
let read_flags = Unix.[O_RDONLY; O_NONBLOCK]
let write_flags = Unix.[O_WRONLY; O_NONBLOCK; O_TRUNC; O_CREAT]

let process_file ~root (strings, count) filename =
  Lwt_pool.use pool (fun () ->
    incr count;
    let%lwt parsed = Lwt_io.with_file ~mode:Input ~flags:read_flags filename (Vue.parse ~filename ~f:Vue.extract_strings) in
    Queue.iter parsed ~f:(fun string ->
      let data = String.chop_prefix filename ~prefix:root |> Option.value ~default:filename in
      String.Table.update strings string ~f:(function
      | None -> String.Set.add String.Set.empty data
      | Some set -> String.Set.add set data
      )
    );
    Lwt.return_unit
  )

let rec traverse ~root strings directory =
  let%lwt entries = Lwt_pool.use pool (fun () -> Lwt_unix.files_of_directory directory |> Lwt_stream.to_list) in
  Lwt_list.iter_p (function
  | filename when String.is_prefix ~prefix:"." filename || String.(=) filename "node_modules" ->
    Lwt.return_unit
  | filename ->
    let path = sprintf "%s/%s" directory filename in
    begin match%lwt Lwt_unix.lstat path with
    | { st_kind = S_REG; _ } when String.is_suffix ~suffix:".vue" filename -> process_file ~root strings path
    | { st_kind = S_DIR; _ } -> traverse ~root strings path
    | _ -> Lwt.return_unit
    end
  ) entries

let fmt s = Yojson.Basic.to_string (`String s)
let json_pair left right first =
  sprintf "%s\n  %s: %s" (if !first then begin first := false; "" end else ",") left right

let write_english english count =
  let path_strings = "strings/english.strings" in
  let path_json = "strings/english.json" in
  let first = ref true in
  let%lwt () =
    Lwt_io.with_file ~flags:write_flags ~mode:Output path_strings (fun oc_strings ->
      Lwt_io.with_file ~flags:write_flags ~mode:Output path_json (fun oc_json ->
        let%lwt () = Lwt.join [
            Lwt_io.write oc_strings header;
            Lwt_io.write_char oc_json '{';
          ]
        in
        let%lwt () = String.Table.fold english ~init:Lwt.return_unit ~f:(fun ~key ~data acc ->
            let fmt_key = fmt key in
            let output_strings = sprintf "/* %s */\n%s = %s;\n\n" data fmt_key fmt_key in
            let output_json = json_pair fmt_key fmt_key first in
            let%lwt () = acc in
            (Lwt_io.write oc_strings output_strings) <&> (Lwt_io.write oc_json output_json)
          )
        in
        Lwt_io.write oc_json "\n}\n"
      )
    )
  in
  sprintf "‚úÖ Processed %d .vue files\n\n‚úÖ Generated '%s' and '%s' with:\n- %d unique strings\n"
    count path_strings path_json (String.Table.length english)
  |> Lwt_io.write_line Lwt_io.stdout

let write_other ~language english other =
  let path_strings = sprintf "strings/%s.strings" language in
  let path_json = sprintf "strings/%s.json" language in
  let first = ref true in
  let%lwt n_left, n_right, n_both =
    Lwt_io.with_file ~flags:write_flags ~mode:Output path_strings (fun oc_strings ->
      Lwt_io.with_file ~flags:write_flags ~mode:Output path_json (fun oc_json ->
        let%lwt () = Lwt.join [
            Lwt_io.write oc_strings header;
            Lwt_io.write_char oc_json '{';
          ]
        in
        let missing_translation key x =
          let fmt_key = fmt key in
          let line_strings = sprintf "/* MISSING TRANSLATION - %s */\n%s = %s;\n\n" x fmt_key fmt_key in
          let line_json = json_pair fmt_key fmt_key first in
          Some (`Left, Lwt_io.write oc_strings line_strings <&> Lwt_io.write oc_json line_json)
        in
        let table = String.Table.merge english other ~f:(fun ~key -> function
          | `Left x -> missing_translation key x
          | `Both (x, y) when String.(key = y) -> missing_translation key x
          | `Both (x, y) ->
            let fmt_key = fmt key in
            let fmt_y = fmt y in
            let line_strings = sprintf "/* %s */\n%s = %s;\n\n" x fmt_key fmt_y in
            let line_json = json_pair fmt_key fmt_y first in
            Some (`Both, Lwt_io.write oc_strings line_strings <&> Lwt_io.write oc_json line_json)
          | `Right y when String.(key = y) -> None
          | `Right y ->
            (* No need to write "deprecated translations" to JSON *)
            let line_strings = sprintf "/* Not currently used */\n%s = %s;\n\n" (fmt key) (fmt y) in
            Some (`Right, Lwt_io.write oc_strings line_strings)
          )
        in
        let%lwt stats = String.Table.fold table ~init:(Lwt.return (0, 0, 0)) ~f:(fun ~key:_ ~data:(w, p) acc ->
            let%lwt () = p in
            let%lwt x, y, z = acc in
            w |> function
            | `Left -> Lwt.return ((succ x), y, z)
            | `Right -> Lwt.return (x, (succ y), z)
            | `Both -> Lwt.return (x, y, (succ z))
          )
        in
        let%lwt () = Lwt_io.write oc_json "\n}\n" in
        Lwt.return stats
      )
    )
  in
  sprintf "‚úÖ Generated '%s' and '%s' with:\n- %d new strings\n- %d existing strings\n- %d unused strings\n"
    path_strings path_json n_left n_both n_right
  |> Lwt_io.write_line Lwt_io.stdout

let directory_exists path =
  begin match%lwt Lwt_unix.stat path with
  | { st_kind = S_DIR; _ } -> Lwt.return_true
  | { st_kind = _; _ } -> failwithf "%s already exists, but is not a directory" path ()
  | exception _ -> Lwt.return_false
  end

let main args =
  let t0 = Time_now.nanoseconds_since_unix_epoch () in
  begin match args with
  | _::"-v"::[] | _::"--version"::[] ->
    let%lwt () = Lwt_io.write_line Lwt_io.stdout (sprintf "Version %s" version) in
    exit 0
  | _::"debug"::"pug"::filename::[] ->
    let%lwt () = Lwt_io.printlf "Debugging %s" filename in
    Lwt_io.with_file ~flags:read_flags ~mode:Input filename (fun ic ->
      Vue.parse ~filename ic ~f:Vue.debug_pug
    )
  | _::[] -> failwith "At least one argument is required"
  | _::directories ->
    (* Check current directory *)
    let%lwt strings_dir_files =
      let git_dir_p = directory_exists ".git" in
      let strings_dir_p = directory_exists "strings" in
      let%lwt git_dir = git_dir_p in
      let%lwt strings_dir = strings_dir_p in
      if not (git_dir || strings_dir) then failwith "This program must be run from the root of your project";
      begin match strings_dir with
      | true -> Lwt_unix.files_of_directory "strings" |> Lwt_stream.to_list
      | false ->
        let%lwt () = Lwt_unix.mkdir "strings" 0o751 in
        Lwt.return_nil
      end
    in
    (* English *)
    let%lwt english =
      let english_list = String.Table.create () in
      let count = ref 0 in
      let%lwt () = Lwt_list.iter_p (fun directory ->
          let root = (String.chop_suffix ~suffix:"/" directory |> Option.value ~default:directory) in
          traverse ~root:(sprintf "%s/" root) (english_list, count) root
        ) directories
      in
      let english = String.Table.map english_list ~f:(fun set ->
          String.Set.to_array set |> String.concat_array ~sep:", "
        )
      in
      let%lwt () = write_english english !count in
      Lwt.return english
    in
    (* Other languages *)
    let%lwt () = Lwt_list.iter_p (fun filename ->
        begin match String.chop_suffix ~suffix:".strings" filename with
        | Some "english" -> Lwt.return_unit
        | Some language ->
          let path = sprintf "strings/%s" filename in
          begin match%lwt Lwt_unix.stat path with
          | { st_kind = S_REG; _ } ->
            let%lwt other = Lwt_io.with_file ~mode:Input ~flags:read_flags path (Parsing.Strings.parse ~filename) in
            write_other ~language english other
          | _ -> Lwt.return_unit
          end
        | None -> Lwt.return_unit
        end
      ) strings_dir_files
    in
    let t1 = Time_now.nanoseconds_since_unix_epoch () in
    Lwt_io.write_line Lwt_io.stdout (sprintf "Completed. (%sms)" Int63.(to_string ((t1 - t0) / (of_int 1_000_000))))

  | _ -> failwith "Expected Unix calling convention"
  end

let () =
  Lwt_main.run (
    try%lwt
      main (Sys.get_argv () |> Array.to_list)
    with
    | (Failure _ as ex) | (Unix.Unix_error _ as ex) | (Exn.Reraised _ as ex) ->
      let message = Utils.Exception.human ex in
      let%lwt () = Lwt_io.write_line Lwt_io.stderr (sprintf "‚ùå An error occured:\n%s" message) in
      exit 1
  )
